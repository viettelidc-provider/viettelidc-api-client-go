/*
 * VTT API
 *
 * API
 *
 * API version: v1
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package iam

import (
	"context"
	"fmt"
	"github.com/antihax/optional"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

type PolicyClientApiService service

/*
PolicyClientApiService
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param policyId

@return DeletePolicyResponse
*/
func (a *PolicyClientApiService) DeletePolicyByPolicyId(ctx context.Context, policyId string) (DeletePolicyResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Delete")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue DeletePolicyResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/policy/{policyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", fmt.Sprintf("%v", policyId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DeletePolicyResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PolicyClientApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accountId
 * @param optional nil or *PolicyClientApiGetAllInlinePoliciesByAccountOpts - Optional Parameters:
     * @param "Name" (optional.String) -
     * @param "PageIndex" (optional.Int32) -  Zero-based page index (0..N)
     * @param "PageSize" (optional.Int32) -  The size of the page to be returned
     * @param "Sort" (optional.Interface of []string) -  Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
@return GetAllInlinePoliciesByAccountResponse
*/

type PolicyClientApiGetAllInlinePoliciesByAccountOpts struct {
	Name      optional.String
	PageIndex optional.Int32
	PageSize  optional.Int32
	Sort      optional.Interface
}

func (a *PolicyClientApiService) GetAllInlinePoliciesByAccount(ctx context.Context, accountId string, localVarOptionals *PolicyClientApiGetAllInlinePoliciesByAccountOpts) (GetAllInlinePoliciesByAccountResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue GetAllInlinePoliciesByAccountResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/policy/inline/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", fmt.Sprintf("%v", accountId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageIndex.IsSet() {
		localVarQueryParams.Add("pageIndex", parameterToString(localVarOptionals.PageIndex.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("pageSize", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GetAllInlinePoliciesByAccountResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PolicyClientApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *PolicyClientApiGetAllPoliciesOpts - Optional Parameters:
     * @param "DomainIdContains" (optional.String) -
     * @param "DomainIdDoesNotContain" (optional.String) -
     * @param "DomainIdEquals" (optional.String) -
     * @param "DomainIdNotEquals" (optional.String) -
     * @param "DomainIdSpecified" (optional.Bool) -
     * @param "DomainIdIn" (optional.Interface of []string) -
     * @param "DomainIdNotIn" (optional.Interface of []string) -
     * @param "IsActiveEquals" (optional.Bool) -
     * @param "IsActiveNotEquals" (optional.Bool) -
     * @param "IsActiveSpecified" (optional.Bool) -
     * @param "IsActiveIn" (optional.Interface of []bool) -
     * @param "IsActiveNotIn" (optional.Interface of []bool) -
     * @param "DeletedDateSpecified" (optional.Bool) -
     * @param "DeletedDateIn" (optional.Interface of []interface{}) -
     * @param "DeletedDateNotIn" (optional.Interface of []interface{}) -
     * @param "PolicyTypeContains" (optional.String) -
     * @param "PolicyTypeDoesNotContain" (optional.String) -
     * @param "PolicyTypeEquals" (optional.String) -
     * @param "PolicyTypeNotEquals" (optional.String) -
     * @param "PolicyTypeSpecified" (optional.Bool) -
     * @param "PolicyTypeIn" (optional.Interface of []string) -
     * @param "PolicyTypeNotIn" (optional.Interface of []string) -
     * @param "PolicyScopeContains" (optional.String) -
     * @param "PolicyScopeDoesNotContain" (optional.String) -
     * @param "PolicyScopeEquals" (optional.String) -
     * @param "PolicyScopeNotEquals" (optional.String) -
     * @param "PolicyScopeSpecified" (optional.Bool) -
     * @param "PolicyScopeIn" (optional.Interface of []string) -
     * @param "PolicyScopeNotIn" (optional.Interface of []string) -
     * @param "NameContains" (optional.String) -
     * @param "NameDoesNotContain" (optional.String) -
     * @param "NameEquals" (optional.String) -
     * @param "NameNotEquals" (optional.String) -
     * @param "NameSpecified" (optional.Bool) -
     * @param "NameIn" (optional.Interface of []string) -
     * @param "NameNotIn" (optional.Interface of []string) -
     * @param "PageIndex" (optional.Int32) -  Zero-based page index (0..N)
     * @param "PageSize" (optional.Int32) -  The size of the page to be returned
     * @param "Sort" (optional.Interface of []string) -  Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
@return GetAllPoliciesResponse
*/

type PolicyClientApiGetAllPoliciesOpts struct {
	DomainIdContains          optional.String
	DomainIdDoesNotContain    optional.String
	DomainIdEquals            optional.String
	DomainIdNotEquals         optional.String
	DomainIdSpecified         optional.Bool
	DomainIdIn                optional.Interface
	DomainIdNotIn             optional.Interface
	IsActiveEquals            optional.Bool
	IsActiveNotEquals         optional.Bool
	IsActiveSpecified         optional.Bool
	IsActiveIn                optional.Interface
	IsActiveNotIn             optional.Interface
	DeletedDateSpecified      optional.Bool
	DeletedDateIn             optional.Interface
	DeletedDateNotIn          optional.Interface
	PolicyTypeContains        optional.String
	PolicyTypeDoesNotContain  optional.String
	PolicyTypeEquals          optional.String
	PolicyTypeNotEquals       optional.String
	PolicyTypeSpecified       optional.Bool
	PolicyTypeIn              optional.Interface
	PolicyTypeNotIn           optional.Interface
	PolicyScopeContains       optional.String
	PolicyScopeDoesNotContain optional.String
	PolicyScopeEquals         optional.String
	PolicyScopeNotEquals      optional.String
	PolicyScopeSpecified      optional.Bool
	PolicyScopeIn             optional.Interface
	PolicyScopeNotIn          optional.Interface
	NameContains              optional.String
	NameDoesNotContain        optional.String
	NameEquals                optional.String
	NameNotEquals             optional.String
	NameSpecified             optional.Bool
	NameIn                    optional.Interface
	NameNotIn                 optional.Interface
	PageIndex                 optional.Int32
	PageSize                  optional.Int32
	Sort                      optional.Interface
}

func (a *PolicyClientApiService) GetAllPolicies(ctx context.Context, localVarOptionals *PolicyClientApiGetAllPoliciesOpts) (GetAllPoliciesResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue GetAllPoliciesResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/policy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.DomainIdContains.IsSet() {
		localVarQueryParams.Add("domainId.contains", parameterToString(localVarOptionals.DomainIdContains.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DomainIdDoesNotContain.IsSet() {
		localVarQueryParams.Add("domainId.doesNotContain", parameterToString(localVarOptionals.DomainIdDoesNotContain.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DomainIdEquals.IsSet() {
		localVarQueryParams.Add("domainId.equals", parameterToString(localVarOptionals.DomainIdEquals.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DomainIdNotEquals.IsSet() {
		localVarQueryParams.Add("domainId.notEquals", parameterToString(localVarOptionals.DomainIdNotEquals.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DomainIdSpecified.IsSet() {
		localVarQueryParams.Add("domainId.specified", parameterToString(localVarOptionals.DomainIdSpecified.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DomainIdIn.IsSet() {
		localVarQueryParams.Add("domainId.in", parameterToString(localVarOptionals.DomainIdIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DomainIdNotIn.IsSet() {
		localVarQueryParams.Add("domainId.notIn", parameterToString(localVarOptionals.DomainIdNotIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IsActiveEquals.IsSet() {
		localVarQueryParams.Add("isActive.equals", parameterToString(localVarOptionals.IsActiveEquals.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsActiveNotEquals.IsSet() {
		localVarQueryParams.Add("isActive.notEquals", parameterToString(localVarOptionals.IsActiveNotEquals.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsActiveSpecified.IsSet() {
		localVarQueryParams.Add("isActive.specified", parameterToString(localVarOptionals.IsActiveSpecified.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsActiveIn.IsSet() {
		localVarQueryParams.Add("isActive.in", parameterToString(localVarOptionals.IsActiveIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IsActiveNotIn.IsSet() {
		localVarQueryParams.Add("isActive.notIn", parameterToString(localVarOptionals.IsActiveNotIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeletedDateSpecified.IsSet() {
		localVarQueryParams.Add("deletedDate.specified", parameterToString(localVarOptionals.DeletedDateSpecified.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeletedDateIn.IsSet() {
		localVarQueryParams.Add("deletedDate.in", parameterToString(localVarOptionals.DeletedDateIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeletedDateNotIn.IsSet() {
		localVarQueryParams.Add("deletedDate.notIn", parameterToString(localVarOptionals.DeletedDateNotIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyTypeContains.IsSet() {
		localVarQueryParams.Add("PolicyType.contains", parameterToString(localVarOptionals.PolicyTypeContains.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyTypeDoesNotContain.IsSet() {
		localVarQueryParams.Add("PolicyType.doesNotContain", parameterToString(localVarOptionals.PolicyTypeDoesNotContain.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyTypeEquals.IsSet() {
		localVarQueryParams.Add("PolicyType.equals", parameterToString(localVarOptionals.PolicyTypeEquals.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyTypeNotEquals.IsSet() {
		localVarQueryParams.Add("PolicyType.notEquals", parameterToString(localVarOptionals.PolicyTypeNotEquals.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyTypeSpecified.IsSet() {
		localVarQueryParams.Add("PolicyType.specified", parameterToString(localVarOptionals.PolicyTypeSpecified.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyTypeIn.IsSet() {
		localVarQueryParams.Add("PolicyType.in", parameterToString(localVarOptionals.PolicyTypeIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyTypeNotIn.IsSet() {
		localVarQueryParams.Add("PolicyType.notIn", parameterToString(localVarOptionals.PolicyTypeNotIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyScopeContains.IsSet() {
		localVarQueryParams.Add("PolicyScope.contains", parameterToString(localVarOptionals.PolicyScopeContains.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyScopeDoesNotContain.IsSet() {
		localVarQueryParams.Add("PolicyScope.doesNotContain", parameterToString(localVarOptionals.PolicyScopeDoesNotContain.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyScopeEquals.IsSet() {
		localVarQueryParams.Add("PolicyScope.equals", parameterToString(localVarOptionals.PolicyScopeEquals.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyScopeNotEquals.IsSet() {
		localVarQueryParams.Add("PolicyScope.notEquals", parameterToString(localVarOptionals.PolicyScopeNotEquals.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyScopeSpecified.IsSet() {
		localVarQueryParams.Add("PolicyScope.specified", parameterToString(localVarOptionals.PolicyScopeSpecified.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyScopeIn.IsSet() {
		localVarQueryParams.Add("PolicyScope.in", parameterToString(localVarOptionals.PolicyScopeIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyScopeNotIn.IsSet() {
		localVarQueryParams.Add("PolicyScope.notIn", parameterToString(localVarOptionals.PolicyScopeNotIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameContains.IsSet() {
		localVarQueryParams.Add("name.contains", parameterToString(localVarOptionals.NameContains.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameDoesNotContain.IsSet() {
		localVarQueryParams.Add("name.doesNotContain", parameterToString(localVarOptionals.NameDoesNotContain.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameEquals.IsSet() {
		localVarQueryParams.Add("name.equals", parameterToString(localVarOptionals.NameEquals.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameNotEquals.IsSet() {
		localVarQueryParams.Add("name.notEquals", parameterToString(localVarOptionals.NameNotEquals.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameSpecified.IsSet() {
		localVarQueryParams.Add("name.specified", parameterToString(localVarOptionals.NameSpecified.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameIn.IsSet() {
		localVarQueryParams.Add("name.in", parameterToString(localVarOptionals.NameIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNotIn.IsSet() {
		localVarQueryParams.Add("name.notIn", parameterToString(localVarOptionals.NameNotIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PageIndex.IsSet() {
		localVarQueryParams.Add("pageIndex", parameterToString(localVarOptionals.PageIndex.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("pageSize", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GetAllPoliciesResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PolicyClientApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accountId
 * @param optional nil or *PolicyClientApiGetAllPolicyBelongToAccountOpts - Optional Parameters:
     * @param "PageIndex" (optional.Int32) -  Zero-based page index (0..N)
     * @param "PageSize" (optional.Int32) -  The size of the page to be returned
     * @param "Sort" (optional.Interface of []string) -  Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
@return GetAllInlineAndUserGroupPoliciesResponse
*/

type PolicyClientApiGetAllPolicyBelongToAccountOpts struct {
	PageIndex optional.Int32
	PageSize  optional.Int32
	Sort      optional.Interface
}

func (a *PolicyClientApiService) GetAllPolicyBelongToAccount(ctx context.Context, accountId string, localVarOptionals *PolicyClientApiGetAllPolicyBelongToAccountOpts) (GetAllInlineAndUserGroupPoliciesResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue GetAllInlineAndUserGroupPoliciesResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/policy/belong-to-account/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", fmt.Sprintf("%v", accountId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.PageIndex.IsSet() {
		localVarQueryParams.Add("pageIndex", parameterToString(localVarOptionals.PageIndex.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("pageSize", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GetAllInlineAndUserGroupPoliciesResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PolicyClientApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userGroupId
 * @param optional nil or *PolicyClientApiGetAllPolicyBelongToUserGroupOpts - Optional Parameters:
     * @param "Name" (optional.String) -
     * @param "PageIndex" (optional.Int32) -  Zero-based page index (0..N)
     * @param "PageSize" (optional.Int32) -  The size of the page to be returned
     * @param "Sort" (optional.Interface of []string) -  Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
@return GetAllPolicyBelongToUserGroupResponse
*/

type PolicyClientApiGetAllPolicyBelongToUserGroupOpts struct {
	Name      optional.String
	PageIndex optional.Int32
	PageSize  optional.Int32
	Sort      optional.Interface
}

func (a *PolicyClientApiService) GetAllPolicyBelongToUserGroup(ctx context.Context, userGroupId string, localVarOptionals *PolicyClientApiGetAllPolicyBelongToUserGroupOpts) (GetAllPolicyBelongToUserGroupResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue GetAllPolicyBelongToUserGroupResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/policy/belong-to-user-group/{userGroupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"userGroupId"+"}", fmt.Sprintf("%v", userGroupId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageIndex.IsSet() {
		localVarQueryParams.Add("pageIndex", parameterToString(localVarOptionals.PageIndex.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("pageSize", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GetAllPolicyBelongToUserGroupResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PolicyClientApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userGroupId
 * @param optional nil or *PolicyClientApiGetAllPolicyNotInOpts - Optional Parameters:
     * @param "Name" (optional.String) -
     * @param "PageIndex" (optional.Int32) -  Zero-based page index (0..N)
     * @param "PageSize" (optional.Int32) -  The size of the page to be returned
     * @param "Sort" (optional.Interface of []string) -  Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
@return GetAllPoliciesNotInUserGroupResponse
*/

type PolicyClientApiGetAllPolicyNotInOpts struct {
	Name      optional.String
	PageIndex optional.Int32
	PageSize  optional.Int32
	Sort      optional.Interface
}

func (a *PolicyClientApiService) GetAllPolicyNotIn(ctx context.Context, userGroupId string, localVarOptionals *PolicyClientApiGetAllPolicyNotInOpts) (GetAllPoliciesNotInUserGroupResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue GetAllPoliciesNotInUserGroupResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/policy/not-in-group/{userGroupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"userGroupId"+"}", fmt.Sprintf("%v", userGroupId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageIndex.IsSet() {
		localVarQueryParams.Add("pageIndex", parameterToString(localVarOptionals.PageIndex.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("pageSize", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GetAllPoliciesNotInUserGroupResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PolicyClientApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *PolicyClientApiGetAllStaticPolicyOpts - Optional Parameters:
     * @param "DomainIdContains" (optional.String) -
     * @param "DomainIdDoesNotContain" (optional.String) -
     * @param "DomainIdEquals" (optional.String) -
     * @param "DomainIdNotEquals" (optional.String) -
     * @param "DomainIdSpecified" (optional.Bool) -
     * @param "DomainIdIn" (optional.Interface of []string) -
     * @param "DomainIdNotIn" (optional.Interface of []string) -
     * @param "IsActiveEquals" (optional.Bool) -
     * @param "IsActiveNotEquals" (optional.Bool) -
     * @param "IsActiveSpecified" (optional.Bool) -
     * @param "IsActiveIn" (optional.Interface of []bool) -
     * @param "IsActiveNotIn" (optional.Interface of []bool) -
     * @param "DeletedDateSpecified" (optional.Bool) -
     * @param "DeletedDateIn" (optional.Interface of []interface{}) -
     * @param "DeletedDateNotIn" (optional.Interface of []interface{}) -
     * @param "PolicyTypeContains" (optional.String) -
     * @param "PolicyTypeDoesNotContain" (optional.String) -
     * @param "PolicyTypeEquals" (optional.String) -
     * @param "PolicyTypeNotEquals" (optional.String) -
     * @param "PolicyTypeSpecified" (optional.Bool) -
     * @param "PolicyTypeIn" (optional.Interface of []string) -
     * @param "PolicyTypeNotIn" (optional.Interface of []string) -
     * @param "PolicyScopeContains" (optional.String) -
     * @param "PolicyScopeDoesNotContain" (optional.String) -
     * @param "PolicyScopeEquals" (optional.String) -
     * @param "PolicyScopeNotEquals" (optional.String) -
     * @param "PolicyScopeSpecified" (optional.Bool) -
     * @param "PolicyScopeIn" (optional.Interface of []string) -
     * @param "PolicyScopeNotIn" (optional.Interface of []string) -
     * @param "NameContains" (optional.String) -
     * @param "NameDoesNotContain" (optional.String) -
     * @param "NameEquals" (optional.String) -
     * @param "NameNotEquals" (optional.String) -
     * @param "NameSpecified" (optional.Bool) -
     * @param "NameIn" (optional.Interface of []string) -
     * @param "NameNotIn" (optional.Interface of []string) -
     * @param "PageIndex" (optional.Int32) -  Zero-based page index (0..N)
     * @param "PageSize" (optional.Int32) -  The size of the page to be returned
     * @param "Sort" (optional.Interface of []string) -  Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
@return GetAllStaticPolicyResponse
*/

type PolicyClientApiGetAllStaticPolicyOpts struct {
	DomainIdContains          optional.String
	DomainIdDoesNotContain    optional.String
	DomainIdEquals            optional.String
	DomainIdNotEquals         optional.String
	DomainIdSpecified         optional.Bool
	DomainIdIn                optional.Interface
	DomainIdNotIn             optional.Interface
	IsActiveEquals            optional.Bool
	IsActiveNotEquals         optional.Bool
	IsActiveSpecified         optional.Bool
	IsActiveIn                optional.Interface
	IsActiveNotIn             optional.Interface
	DeletedDateSpecified      optional.Bool
	DeletedDateIn             optional.Interface
	DeletedDateNotIn          optional.Interface
	PolicyTypeContains        optional.String
	PolicyTypeDoesNotContain  optional.String
	PolicyTypeEquals          optional.String
	PolicyTypeNotEquals       optional.String
	PolicyTypeSpecified       optional.Bool
	PolicyTypeIn              optional.Interface
	PolicyTypeNotIn           optional.Interface
	PolicyScopeContains       optional.String
	PolicyScopeDoesNotContain optional.String
	PolicyScopeEquals         optional.String
	PolicyScopeNotEquals      optional.String
	PolicyScopeSpecified      optional.Bool
	PolicyScopeIn             optional.Interface
	PolicyScopeNotIn          optional.Interface
	NameContains              optional.String
	NameDoesNotContain        optional.String
	NameEquals                optional.String
	NameNotEquals             optional.String
	NameSpecified             optional.Bool
	NameIn                    optional.Interface
	NameNotIn                 optional.Interface
	PageIndex                 optional.Int32
	PageSize                  optional.Int32
	Sort                      optional.Interface
}

func (a *PolicyClientApiService) GetAllStaticPolicy(ctx context.Context, localVarOptionals *PolicyClientApiGetAllStaticPolicyOpts) (GetAllStaticPolicyResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue GetAllStaticPolicyResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/policy/static"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.DomainIdContains.IsSet() {
		localVarQueryParams.Add("domainId.contains", parameterToString(localVarOptionals.DomainIdContains.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DomainIdDoesNotContain.IsSet() {
		localVarQueryParams.Add("domainId.doesNotContain", parameterToString(localVarOptionals.DomainIdDoesNotContain.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DomainIdEquals.IsSet() {
		localVarQueryParams.Add("domainId.equals", parameterToString(localVarOptionals.DomainIdEquals.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DomainIdNotEquals.IsSet() {
		localVarQueryParams.Add("domainId.notEquals", parameterToString(localVarOptionals.DomainIdNotEquals.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DomainIdSpecified.IsSet() {
		localVarQueryParams.Add("domainId.specified", parameterToString(localVarOptionals.DomainIdSpecified.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DomainIdIn.IsSet() {
		localVarQueryParams.Add("domainId.in", parameterToString(localVarOptionals.DomainIdIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DomainIdNotIn.IsSet() {
		localVarQueryParams.Add("domainId.notIn", parameterToString(localVarOptionals.DomainIdNotIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IsActiveEquals.IsSet() {
		localVarQueryParams.Add("isActive.equals", parameterToString(localVarOptionals.IsActiveEquals.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsActiveNotEquals.IsSet() {
		localVarQueryParams.Add("isActive.notEquals", parameterToString(localVarOptionals.IsActiveNotEquals.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsActiveSpecified.IsSet() {
		localVarQueryParams.Add("isActive.specified", parameterToString(localVarOptionals.IsActiveSpecified.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsActiveIn.IsSet() {
		localVarQueryParams.Add("isActive.in", parameterToString(localVarOptionals.IsActiveIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IsActiveNotIn.IsSet() {
		localVarQueryParams.Add("isActive.notIn", parameterToString(localVarOptionals.IsActiveNotIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeletedDateSpecified.IsSet() {
		localVarQueryParams.Add("deletedDate.specified", parameterToString(localVarOptionals.DeletedDateSpecified.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeletedDateIn.IsSet() {
		localVarQueryParams.Add("deletedDate.in", parameterToString(localVarOptionals.DeletedDateIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeletedDateNotIn.IsSet() {
		localVarQueryParams.Add("deletedDate.notIn", parameterToString(localVarOptionals.DeletedDateNotIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyTypeContains.IsSet() {
		localVarQueryParams.Add("PolicyType.contains", parameterToString(localVarOptionals.PolicyTypeContains.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyTypeDoesNotContain.IsSet() {
		localVarQueryParams.Add("PolicyType.doesNotContain", parameterToString(localVarOptionals.PolicyTypeDoesNotContain.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyTypeEquals.IsSet() {
		localVarQueryParams.Add("PolicyType.equals", parameterToString(localVarOptionals.PolicyTypeEquals.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyTypeNotEquals.IsSet() {
		localVarQueryParams.Add("PolicyType.notEquals", parameterToString(localVarOptionals.PolicyTypeNotEquals.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyTypeSpecified.IsSet() {
		localVarQueryParams.Add("PolicyType.specified", parameterToString(localVarOptionals.PolicyTypeSpecified.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyTypeIn.IsSet() {
		localVarQueryParams.Add("PolicyType.in", parameterToString(localVarOptionals.PolicyTypeIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyTypeNotIn.IsSet() {
		localVarQueryParams.Add("PolicyType.notIn", parameterToString(localVarOptionals.PolicyTypeNotIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyScopeContains.IsSet() {
		localVarQueryParams.Add("PolicyScope.contains", parameterToString(localVarOptionals.PolicyScopeContains.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyScopeDoesNotContain.IsSet() {
		localVarQueryParams.Add("PolicyScope.doesNotContain", parameterToString(localVarOptionals.PolicyScopeDoesNotContain.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyScopeEquals.IsSet() {
		localVarQueryParams.Add("PolicyScope.equals", parameterToString(localVarOptionals.PolicyScopeEquals.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyScopeNotEquals.IsSet() {
		localVarQueryParams.Add("PolicyScope.notEquals", parameterToString(localVarOptionals.PolicyScopeNotEquals.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyScopeSpecified.IsSet() {
		localVarQueryParams.Add("PolicyScope.specified", parameterToString(localVarOptionals.PolicyScopeSpecified.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyScopeIn.IsSet() {
		localVarQueryParams.Add("PolicyScope.in", parameterToString(localVarOptionals.PolicyScopeIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyScopeNotIn.IsSet() {
		localVarQueryParams.Add("PolicyScope.notIn", parameterToString(localVarOptionals.PolicyScopeNotIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameContains.IsSet() {
		localVarQueryParams.Add("name.contains", parameterToString(localVarOptionals.NameContains.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameDoesNotContain.IsSet() {
		localVarQueryParams.Add("name.doesNotContain", parameterToString(localVarOptionals.NameDoesNotContain.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameEquals.IsSet() {
		localVarQueryParams.Add("name.equals", parameterToString(localVarOptionals.NameEquals.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameNotEquals.IsSet() {
		localVarQueryParams.Add("name.notEquals", parameterToString(localVarOptionals.NameNotEquals.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameSpecified.IsSet() {
		localVarQueryParams.Add("name.specified", parameterToString(localVarOptionals.NameSpecified.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameIn.IsSet() {
		localVarQueryParams.Add("name.in", parameterToString(localVarOptionals.NameIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNotIn.IsSet() {
		localVarQueryParams.Add("name.notIn", parameterToString(localVarOptionals.NameNotIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PageIndex.IsSet() {
		localVarQueryParams.Add("pageIndex", parameterToString(localVarOptionals.PageIndex.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("pageSize", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GetAllStaticPolicyResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PolicyClientApiService
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param policyId

@return GetDetailPolicyResponse
*/
func (a *PolicyClientApiService) GetDetailPolicyResponse(ctx context.Context, policyId string) (GetDetailPolicyResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue GetDetailPolicyResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/policy/{policyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", fmt.Sprintf("%v", policyId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GetDetailPolicyResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PolicyClientApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accountId
 * @param optional nil or *PolicyClientApiGetPoliciesAccountNotHasOpts - Optional Parameters:
     * @param "Name" (optional.String) -
     * @param "PageIndex" (optional.Int32) -  Zero-based page index (0..N)
     * @param "PageSize" (optional.Int32) -  The size of the page to be returned
     * @param "Sort" (optional.Interface of []string) -  Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
@return GetAllPoliciesNotInAccountResponses
*/

type PolicyClientApiGetPoliciesAccountNotHasOpts struct {
	Name      optional.String
	PageIndex optional.Int32
	PageSize  optional.Int32
	Sort      optional.Interface
}

func (a *PolicyClientApiService) GetPoliciesAccountNotHas(ctx context.Context, accountId string, localVarOptionals *PolicyClientApiGetPoliciesAccountNotHasOpts) (GetAllPoliciesNotInAccountResponses, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue GetAllPoliciesNotInAccountResponses
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/policy/account-not-has/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", fmt.Sprintf("%v", accountId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageIndex.IsSet() {
		localVarQueryParams.Add("pageIndex", parameterToString(localVarOptionals.PageIndex.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("pageSize", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GetAllPoliciesNotInAccountResponses
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PolicyClientApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *PolicyClientApiGetPolicyByUserOpts - Optional Parameters:
     * @param "DomainIdContains" (optional.String) -
     * @param "DomainIdDoesNotContain" (optional.String) -
     * @param "DomainIdEquals" (optional.String) -
     * @param "DomainIdNotEquals" (optional.String) -
     * @param "DomainIdSpecified" (optional.Bool) -
     * @param "DomainIdIn" (optional.Interface of []string) -
     * @param "DomainIdNotIn" (optional.Interface of []string) -
     * @param "IsActiveEquals" (optional.Bool) -
     * @param "IsActiveNotEquals" (optional.Bool) -
     * @param "IsActiveSpecified" (optional.Bool) -
     * @param "IsActiveIn" (optional.Interface of []bool) -
     * @param "IsActiveNotIn" (optional.Interface of []bool) -
     * @param "DeletedDateSpecified" (optional.Bool) -
     * @param "DeletedDateIn" (optional.Interface of []interface{}) -
     * @param "DeletedDateNotIn" (optional.Interface of []interface{}) -
     * @param "PolicyTypeContains" (optional.String) -
     * @param "PolicyTypeDoesNotContain" (optional.String) -
     * @param "PolicyTypeEquals" (optional.String) -
     * @param "PolicyTypeNotEquals" (optional.String) -
     * @param "PolicyTypeSpecified" (optional.Bool) -
     * @param "PolicyTypeIn" (optional.Interface of []string) -
     * @param "PolicyTypeNotIn" (optional.Interface of []string) -
     * @param "PolicyScopeContains" (optional.String) -
     * @param "PolicyScopeDoesNotContain" (optional.String) -
     * @param "PolicyScopeEquals" (optional.String) -
     * @param "PolicyScopeNotEquals" (optional.String) -
     * @param "PolicyScopeSpecified" (optional.Bool) -
     * @param "PolicyScopeIn" (optional.Interface of []string) -
     * @param "PolicyScopeNotIn" (optional.Interface of []string) -
     * @param "NameContains" (optional.String) -
     * @param "NameDoesNotContain" (optional.String) -
     * @param "NameEquals" (optional.String) -
     * @param "NameNotEquals" (optional.String) -
     * @param "NameSpecified" (optional.Bool) -
     * @param "NameIn" (optional.Interface of []string) -
     * @param "NameNotIn" (optional.Interface of []string) -
     * @param "PageIndex" (optional.Int32) -  Zero-based page index (0..N)
     * @param "PageSize" (optional.Int32) -  The size of the page to be returned
     * @param "Sort" (optional.Interface of []string) -  Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
@return GetPoliciesByUserResponse
*/

type PolicyClientApiGetPolicyByUserOpts struct {
	DomainIdContains          optional.String
	DomainIdDoesNotContain    optional.String
	DomainIdEquals            optional.String
	DomainIdNotEquals         optional.String
	DomainIdSpecified         optional.Bool
	DomainIdIn                optional.Interface
	DomainIdNotIn             optional.Interface
	IsActiveEquals            optional.Bool
	IsActiveNotEquals         optional.Bool
	IsActiveSpecified         optional.Bool
	IsActiveIn                optional.Interface
	IsActiveNotIn             optional.Interface
	DeletedDateSpecified      optional.Bool
	DeletedDateIn             optional.Interface
	DeletedDateNotIn          optional.Interface
	PolicyTypeContains        optional.String
	PolicyTypeDoesNotContain  optional.String
	PolicyTypeEquals          optional.String
	PolicyTypeNotEquals       optional.String
	PolicyTypeSpecified       optional.Bool
	PolicyTypeIn              optional.Interface
	PolicyTypeNotIn           optional.Interface
	PolicyScopeContains       optional.String
	PolicyScopeDoesNotContain optional.String
	PolicyScopeEquals         optional.String
	PolicyScopeNotEquals      optional.String
	PolicyScopeSpecified      optional.Bool
	PolicyScopeIn             optional.Interface
	PolicyScopeNotIn          optional.Interface
	NameContains              optional.String
	NameDoesNotContain        optional.String
	NameEquals                optional.String
	NameNotEquals             optional.String
	NameSpecified             optional.Bool
	NameIn                    optional.Interface
	NameNotIn                 optional.Interface
	PageIndex                 optional.Int32
	PageSize                  optional.Int32
	Sort                      optional.Interface
}

func (a *PolicyClientApiService) GetPolicyByUser(ctx context.Context, localVarOptionals *PolicyClientApiGetPolicyByUserOpts) (GetPoliciesByUserResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue GetPoliciesByUserResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/policy/custom"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.DomainIdContains.IsSet() {
		localVarQueryParams.Add("domainId.contains", parameterToString(localVarOptionals.DomainIdContains.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DomainIdDoesNotContain.IsSet() {
		localVarQueryParams.Add("domainId.doesNotContain", parameterToString(localVarOptionals.DomainIdDoesNotContain.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DomainIdEquals.IsSet() {
		localVarQueryParams.Add("domainId.equals", parameterToString(localVarOptionals.DomainIdEquals.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DomainIdNotEquals.IsSet() {
		localVarQueryParams.Add("domainId.notEquals", parameterToString(localVarOptionals.DomainIdNotEquals.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DomainIdSpecified.IsSet() {
		localVarQueryParams.Add("domainId.specified", parameterToString(localVarOptionals.DomainIdSpecified.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DomainIdIn.IsSet() {
		localVarQueryParams.Add("domainId.in", parameterToString(localVarOptionals.DomainIdIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DomainIdNotIn.IsSet() {
		localVarQueryParams.Add("domainId.notIn", parameterToString(localVarOptionals.DomainIdNotIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IsActiveEquals.IsSet() {
		localVarQueryParams.Add("isActive.equals", parameterToString(localVarOptionals.IsActiveEquals.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsActiveNotEquals.IsSet() {
		localVarQueryParams.Add("isActive.notEquals", parameterToString(localVarOptionals.IsActiveNotEquals.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsActiveSpecified.IsSet() {
		localVarQueryParams.Add("isActive.specified", parameterToString(localVarOptionals.IsActiveSpecified.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsActiveIn.IsSet() {
		localVarQueryParams.Add("isActive.in", parameterToString(localVarOptionals.IsActiveIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IsActiveNotIn.IsSet() {
		localVarQueryParams.Add("isActive.notIn", parameterToString(localVarOptionals.IsActiveNotIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeletedDateSpecified.IsSet() {
		localVarQueryParams.Add("deletedDate.specified", parameterToString(localVarOptionals.DeletedDateSpecified.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeletedDateIn.IsSet() {
		localVarQueryParams.Add("deletedDate.in", parameterToString(localVarOptionals.DeletedDateIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DeletedDateNotIn.IsSet() {
		localVarQueryParams.Add("deletedDate.notIn", parameterToString(localVarOptionals.DeletedDateNotIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyTypeContains.IsSet() {
		localVarQueryParams.Add("PolicyType.contains", parameterToString(localVarOptionals.PolicyTypeContains.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyTypeDoesNotContain.IsSet() {
		localVarQueryParams.Add("PolicyType.doesNotContain", parameterToString(localVarOptionals.PolicyTypeDoesNotContain.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyTypeEquals.IsSet() {
		localVarQueryParams.Add("PolicyType.equals", parameterToString(localVarOptionals.PolicyTypeEquals.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyTypeNotEquals.IsSet() {
		localVarQueryParams.Add("PolicyType.notEquals", parameterToString(localVarOptionals.PolicyTypeNotEquals.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyTypeSpecified.IsSet() {
		localVarQueryParams.Add("PolicyType.specified", parameterToString(localVarOptionals.PolicyTypeSpecified.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyTypeIn.IsSet() {
		localVarQueryParams.Add("PolicyType.in", parameterToString(localVarOptionals.PolicyTypeIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyTypeNotIn.IsSet() {
		localVarQueryParams.Add("PolicyType.notIn", parameterToString(localVarOptionals.PolicyTypeNotIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyScopeContains.IsSet() {
		localVarQueryParams.Add("PolicyScope.contains", parameterToString(localVarOptionals.PolicyScopeContains.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyScopeDoesNotContain.IsSet() {
		localVarQueryParams.Add("PolicyScope.doesNotContain", parameterToString(localVarOptionals.PolicyScopeDoesNotContain.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyScopeEquals.IsSet() {
		localVarQueryParams.Add("PolicyScope.equals", parameterToString(localVarOptionals.PolicyScopeEquals.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyScopeNotEquals.IsSet() {
		localVarQueryParams.Add("PolicyScope.notEquals", parameterToString(localVarOptionals.PolicyScopeNotEquals.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyScopeSpecified.IsSet() {
		localVarQueryParams.Add("PolicyScope.specified", parameterToString(localVarOptionals.PolicyScopeSpecified.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyScopeIn.IsSet() {
		localVarQueryParams.Add("PolicyScope.in", parameterToString(localVarOptionals.PolicyScopeIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyScopeNotIn.IsSet() {
		localVarQueryParams.Add("PolicyScope.notIn", parameterToString(localVarOptionals.PolicyScopeNotIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameContains.IsSet() {
		localVarQueryParams.Add("name.contains", parameterToString(localVarOptionals.NameContains.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameDoesNotContain.IsSet() {
		localVarQueryParams.Add("name.doesNotContain", parameterToString(localVarOptionals.NameDoesNotContain.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameEquals.IsSet() {
		localVarQueryParams.Add("name.equals", parameterToString(localVarOptionals.NameEquals.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameNotEquals.IsSet() {
		localVarQueryParams.Add("name.notEquals", parameterToString(localVarOptionals.NameNotEquals.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameSpecified.IsSet() {
		localVarQueryParams.Add("name.specified", parameterToString(localVarOptionals.NameSpecified.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameIn.IsSet() {
		localVarQueryParams.Add("name.in", parameterToString(localVarOptionals.NameIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.NameNotIn.IsSet() {
		localVarQueryParams.Add("name.notIn", parameterToString(localVarOptionals.NameNotIn.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PageIndex.IsSet() {
		localVarQueryParams.Add("pageIndex", parameterToString(localVarOptionals.PageIndex.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("pageSize", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GetPoliciesByUserResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PolicyClientApiService
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body

@return SavePolicyResponse
*/
func (a *PolicyClientApiService) SavePolicy(ctx context.Context, body SavePolicyRequest) (SavePolicyResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue SavePolicyResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/policy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v SavePolicyResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
PolicyClientApiService
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body

@return UpdatePolicyResponse
*/
func (a *PolicyClientApiService) UpdatePolicy(ctx context.Context, body UpdatePolicyRequest) (UpdatePolicyResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Put")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue UpdatePolicyResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/policy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v UpdatePolicyResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
